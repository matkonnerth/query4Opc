First step:
only use browse service
no multiple returns
no where clauses
we do not try to change direction of reference

GraphTraversal and Filtering

Source

"Generates" nodes, example is the hierachical visitor.

HierachicalVisitor
Sinks can be uses as a source with SinkToSource

Filter

Filters nodes on a certain attribute, for example the typedefinition id.
ReferenceFilter
TypeFilter (specialization of a type filter)

a Source, multiple filters and a sink can be combined to a FilterChain.

Sink

stores nodes at the end of filtering

Path

is a alternating sequence of nodes and relationships.

(n1)-[r1]-(n2)-[r2]-(n3)

SimplePath

(Node)-[Relationship]-(Node)

can be broken down to a FilterChain with a source, a referenceFilter and a sink.
Sink can be used again as source. With that concept a variable length path can be reduced to 1 simple path and n appended path.

Sink can be also used as target for a referenceFilter. This implementation is missing.

With that concept we can reduce a SimplePath to a vector of results and reuse them.
A FilterChain has a direction (a source, filters and a sink) and only reference descriptions "generated by the source are preserved". So from a path (obj:Object)-[:HasTypeDefinition]->(:ObjectType{NodeId:"MyType"}) only the objects are preserved (in this case it doesn't make sense to preserve the ReferenceType and the ObjectType, it's clear).

But what about this case: (obj:Object)-[:HasProperty]->(var:Variable), would be interesting to preserve the variable. Could be done by saving the match in the ReferenceFilter.

Strategy for reduction

When we reduce from left to right, we have to preserve the right side (sink side of filterchain) of the SimplePath

(n1)-[r1]-(n2)-[r2]-(n3)-[r3]-(n4)

(n2')-[r2]-(n3)-[r3]-(n4)
n2' .. subset of n2 matching n1

(n3')-[r3]-(n4)
n3' .. subset of n3 matching n2'

Result (n3'')
n3'' .. subset of n3' matching n4

When we reduce from right to left, we have to preserve the left side (source side of filterchain, current impl) of the SimplePath
(n1)-[r1]-(n2)-[r2]-(n3)-[r3]-(n4)

(n1)-[r1]-(n2)-[r2]-(n3')
n3' .. subset of n3 matching n4

(n1)-[r1]-(n2')
n2' .. subset of n2 matchin n3'

Result(n1')
n1' .. subset of n1 matching n2'

That means we have to bring the wanted result node completely to the left.

Direction of the relationship play an important role, take a look a this example:
(:Variable)<-[:HasProperty]-(obj:Object)-[:HasTypeDefinition]->(t:ObjectType{NodeId:\"MyType\"}) RETURN obj

can be rewritten to

(obj:Object)-[:HasProperty]->(:Variable)
(obj)-[:HasTypeDefinition]->(t:ObjectType{NodeId:\"MyType\"})


We can decide whether we want to start with first or second filterchain. From a performance prospective it would be good to start with the objects matching the objectType.

Metrics
We could say: A typical nodeset has 100 objectTypes with 10 instances each




EmptyPath

is a path with only one node pattern.

Pattern
NodePattern
RelationshipPattern

How to specify the root of the HierachicalVisitor?
Could be done with this:
`match(root:Object{NodeId:"BaseInstance"})-[:HierachicalReferences*0..]->(obj:Objects` \

How to reduce this match clause? Would be a really good optimization.
